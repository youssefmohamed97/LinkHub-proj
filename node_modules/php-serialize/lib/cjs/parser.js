"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var PARSER_TYPES = {
    N: 'null',
    i: 'int',
    d: 'float',
    b: 'boolean',
    s: 'string',
    a: 'array-object',
    C: 'serializable-class',
    O: 'notserializable-class',
};
var Parser = /** @class */ (function () {
    function Parser(contents, index, options) {
        this.contents = contents;
        this.index = index;
        this.options = options;
    }
    Parser.prototype.error = function (message) {
        if (message === void 0) { message = 'Syntax Error'; }
        return new Error(message + " at index " + this.index + " while unserializing payload");
    };
    Parser.prototype.advance = function (index) {
        this.index += index;
    };
    Parser.prototype.readAhead = function (index) {
        var contents = this.peekAhead(index);
        this.index += index;
        return contents;
    };
    Parser.prototype.readUntil = function (expected) {
        var index = this.contents.indexOf(expected, this.index);
        if (index === -1) {
            throw this.error("Expected '" + expected + "'");
        }
        return this.readAhead(index - this.index);
    };
    Parser.prototype.peekAhead = function (index) {
        return this.contents.toString(this.options.encoding, this.index, this.index + index);
    };
    Parser.prototype.seekExpected = function (contents) {
        var slice = this.readAhead(contents.length);
        if (slice !== contents) {
            this.index -= contents.length;
            throw this.error("Expected '" + contents + "'");
        }
    };
    Parser.prototype.getType = function () {
        var _a = __read(this.readAhead(2), 2), type = _a[0], ps = _a[1];
        var parserType = PARSER_TYPES[type];
        if (!parserType) {
            throw this.error('Unknown type');
        }
        if (parserType === 'null' ? ps !== ';' : ps !== ':') {
            throw this.error();
        }
        return parserType;
    };
    Parser.prototype.getLength = function () {
        var length = parseInt(this.readUntil(':'), 10);
        if (Number.isNaN(length)) {
            throw this.error();
        }
        return length;
    };
    Parser.prototype.getByLength = function (startSequence, endSequence, callback) {
        var length = this.getLength();
        this.seekExpected(":" + startSequence);
        var result = callback(length);
        this.seekExpected(endSequence);
        return result;
    };
    return Parser;
}());
exports.default = Parser;
