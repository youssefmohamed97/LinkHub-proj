{"version":3,"file":"crypto.js","sourceRoot":"","sources":["../src/crypto.ts"],"names":[],"mappings":";;;AAAA,iCAAiC;AACjC,uCAA2C;AAEpC,MAAM,QAAQ,GAAG,CACtB,GAAoB,EAC0C,EAAE;IAChE,IAAA,wBAAc,EAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC;IAEvC,IAAI,OAAO,GAAG,KAAK,QAAQ;QAAE,OAAO,GAAG,CAAC;IACxC,IAAI,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,GAAG,CAAC;IAEhD,MAAM,UAAU,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IAEzC,IAAI,UAAU,EAAE;QACd,MAAM,UAAU,GAAG;YACjB,6BAA6B;YAC7B,GAAG,UAAU;YACb,2BAA2B;YAC3B,EAAE;SACH,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACb,OAAO,UAAU,CAAC;KACnB;IAED,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,CAAC;AACjC,CAAC,CAAC;AArBW,QAAA,QAAQ,YAqBnB;AAEK,MAAM,SAAS,GAAG,CAAC,IAAY,EAAU,EAAE;IAChD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;IACrC,IAAA,wBAAc,EAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;IACzC,IAAI,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE3B,IAAI,GAAG,CAAC,OAAO,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;QAAE,GAAG,GAAG,+BAA+B,GAAG,GAAG,CAAC;IAC3F,IAAI,GAAG,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAAE,GAAG,GAAG,GAAG,GAAG,+BAA+B,CAAC;IAEzF,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AATW,QAAA,SAAS,aASpB;AAEK,MAAM,gBAAgB,GAAG,GAAW,EAAE;IAC3C,OAAO,GAAG,GAAG,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;AACtD,CAAC,CAAC;AAFW,QAAA,gBAAgB,oBAE3B;AAEK,MAAM,4BAA4B,GAAG,CAAC,WAAmB,EAAU,EAAE;IAC1E,wIAAwI;IACxI,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,mCAAmC,EAAE,EAAE,CAAC,CAAC;IAC3E,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,iCAAiC,EAAE,EAAE,CAAC,CAAC;IACzE,WAAW,GAAG,WAAW,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IACjD,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC;AANW,QAAA,4BAA4B,gCAMvC","sourcesContent":["import * as crypto from \"crypto\";\nimport { assertRequired } from \"./utility\";\n\nexport const keyToPEM = (\n  key: string | Buffer\n): typeof key extends string | Buffer ? string | Buffer : Error => {\n  assertRequired(key, \"key is required\");\n\n  if (typeof key !== \"string\") return key;\n  if (key.split(/\\r?\\n/).length !== 1) return key;\n\n  const matchedKey = key.match(/.{1,64}/g);\n\n  if (matchedKey) {\n    const wrappedKey = [\n      \"-----BEGIN PRIVATE KEY-----\",\n      ...matchedKey,\n      \"-----END PRIVATE KEY-----\",\n      \"\",\n    ].join(\"\\n\");\n    return wrappedKey;\n  }\n\n  throw new Error(\"Invalid key\");\n};\n\nexport const certToPEM = (cert: string): string => {\n  const lines = cert.match(/.{1,64}/g);\n  assertRequired(lines, \"cert is invalid\");\n  let pem = lines.join(\"\\n\");\n\n  if (pem.indexOf(\"-BEGIN CERTIFICATE-\") === -1) pem = \"-----BEGIN CERTIFICATE-----\\n\" + pem;\n  if (pem.indexOf(\"-END CERTIFICATE-\") === -1) pem = pem + \"\\n-----END CERTIFICATE-----\\n\";\n\n  return pem;\n};\n\nexport const generateUniqueId = (): string => {\n  return \"_\" + crypto.randomBytes(20).toString(\"hex\");\n};\n\nexport const removeCertPEMHeaderAndFooter = (certificate: string): string => {\n  // These headers and footers are standard: https://www.ssl.com/guide/pem-der-crt-and-cer-x-509-encodings-and-conversions/#ftoc-heading-1\n  certificate = certificate.replace(/-----BEGIN CERTIFICATE-----\\r?\\n?/, \"\");\n  certificate = certificate.replace(/-----END CERTIFICATE-----\\r?\\n?/, \"\");\n  certificate = certificate.replace(/\\r\\n/g, \"\\n\");\n  return certificate;\n};\n"]}