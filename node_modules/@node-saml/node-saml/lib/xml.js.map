{"version":3,"file":"xml.js","sourceRoot":"","sources":["../src/xml.ts"],"names":[],"mappings":"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","sourcesContent":["import * as util from \"util\";\nimport * as xmlCrypto from \"xml-crypto\";\nimport * as xmlenc from \"xml-encryption\";\nimport * as xmldom from \"@xmldom/xmldom\";\nimport * as xml2js from \"xml2js\";\nimport * as xmlbuilder from \"xmlbuilder\";\nimport {\n  isValidSamlSigningOptions,\n  NameID,\n  SamlSigningOptions,\n  XmlJsObject,\n  XMLOutput,\n  XmlSignatureLocation,\n} from \"./types\";\nimport * as algorithms from \"./algorithms\";\nimport { assertRequired } from \"./utility\";\nimport { certToPEM } from \"./crypto\";\n\ntype SelectedValue = string | number | boolean | Node;\n\nconst selectXPath = <T extends SelectedValue>(\n  guard: (values: SelectedValue[]) => values is T[],\n  node: Node,\n  xpath: string\n): T[] => {\n  const result = xmlCrypto.xpath(node, xpath);\n  if (!guard(result)) {\n    throw new Error(\"invalid xpath return type\");\n  }\n  return result;\n};\n\nconst attributesXPathTypeGuard = (values: SelectedValue[]): values is Attr[] => {\n  return values.every((value) => {\n    if (typeof value != \"object\") {\n      return false;\n    }\n    return typeof value.nodeType === \"number\" && value.nodeType === value.ATTRIBUTE_NODE;\n  });\n};\n\nconst elementsXPathTypeGuard = (values: SelectedValue[]): values is Element[] => {\n  return values.every((value) => {\n    if (typeof value != \"object\") {\n      return false;\n    }\n    return typeof value.nodeType === \"number\" && value.nodeType === value.ELEMENT_NODE;\n  });\n};\n\nexport const xpath = {\n  selectAttributes: (node: Node, xpath: string): Attr[] =>\n    selectXPath(attributesXPathTypeGuard, node, xpath),\n  selectElements: (node: Node, xpath: string): Element[] =>\n    selectXPath(elementsXPathTypeGuard, node, xpath),\n};\n\nexport const decryptXml = async (xml: string, decryptionKey: string | Buffer) =>\n  util.promisify(xmlenc.decrypt).bind(xmlenc)(xml, { key: decryptionKey });\n\n/**\n * we can use this utility before passing XML to `xml-crypto`\n * we are considered the XML processor and are responsible for newline normalization\n * https://github.com/node-saml/passport-saml/issues/431#issuecomment-718132752\n */\nconst normalizeNewlines = (xml: string): string => {\n  return xml.replace(/\\r\\n?/g, \"\\n\");\n};\n\n/**\n * This function checks that the |currentNode| in the |fullXml| document contains exactly 1 valid\n *   signature of the |currentNode|.\n *\n * See https://github.com/bergie/passport-saml/issues/19 for references to some of the attack\n *   vectors against SAML signature verification.\n */\nexport const validateSignature = (\n  fullXml: string,\n  currentNode: Element,\n  certs: string[]\n): boolean => {\n  const xpathSigQuery =\n    \".//*[\" +\n    \"local-name(.)='Signature' and \" +\n    \"namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#' and \" +\n    \"descendant::*[local-name(.)='Reference' and @URI='#\" +\n    currentNode.getAttribute(\"ID\") +\n    \"']\" +\n    \"]\";\n  const signatures = xpath.selectElements(currentNode, xpathSigQuery);\n  // This function is expecting to validate exactly one signature, so if we find more or fewer\n  //   than that, reject.\n  if (signatures.length !== 1) {\n    return false;\n  }\n  const xpathTransformQuery =\n    \".//*[\" +\n    \"local-name(.)='Transform' and \" +\n    \"namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#' and \" +\n    \"ancestor::*[local-name(.)='Reference' and @URI='#\" +\n    currentNode.getAttribute(\"ID\") +\n    \"']\" +\n    \"]\";\n  const transforms = xpath.selectElements(currentNode, xpathTransformQuery);\n  // Reject also XMLDSIG with more than 2 Transform\n  if (transforms.length > 2) {\n    // do not return false, throw an error so that it can be caught by tests differently\n    throw new Error(\"Invalid signature, too many transforms\");\n  }\n\n  const signature = signatures[0];\n  return certs.some((certToCheck) => {\n    return validateXmlSignatureForCert(signature, certToPEM(certToCheck), fullXml, currentNode);\n  });\n};\n\n/**\n * This function checks that the |signature| is signed with a given |cert|.\n */\nexport const validateXmlSignatureForCert = (\n  signature: Node,\n  certPem: string,\n  fullXml: string,\n  currentNode: Element\n): boolean => {\n  const sig = new xmlCrypto.SignedXml();\n  sig.keyInfoProvider = {\n    file: \"\",\n    getKeyInfo: () => \"<X509Data></X509Data>\",\n    getKey: () => Buffer.from(certPem),\n  };\n  sig.loadSignature(signature);\n  // We expect each signature to contain exactly one reference to the top level of the xml we\n  //   are validating, so if we see anything else, reject.\n  if (sig.references.length != 1) return false;\n  const refUri = sig.references[0].uri;\n  assertRequired(refUri, \"signature reference uri not found\");\n  const refId = refUri[0] === \"#\" ? refUri.substring(1) : refUri;\n  // If we can't find the reference at the top level, reject\n  const idAttribute = currentNode.getAttribute(\"ID\") ? \"ID\" : \"Id\";\n  if (currentNode.getAttribute(idAttribute) != refId) return false;\n  // If we find any extra referenced nodes, reject.  (xml-crypto only verifies one digest, so\n  //   multiple candidate references is bad news)\n  const totalReferencedNodes = xpath.selectElements(\n    currentNode.ownerDocument,\n    \"//*[@\" + idAttribute + \"='\" + refId + \"']\"\n  );\n\n  if (totalReferencedNodes.length > 1) {\n    return false;\n  }\n  fullXml = normalizeNewlines(fullXml);\n  return sig.checkSignature(fullXml);\n};\n\nexport const signXml = (\n  xml: string,\n  xpath: string,\n  location: XmlSignatureLocation,\n  options: SamlSigningOptions\n): string => {\n  const defaultTransforms = [\n    \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\",\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\",\n  ];\n\n  if (!xml) throw new Error(\"samlMessage is required\");\n  if (!location) throw new Error(\"location is required\");\n  if (!options) throw new Error(\"options is required\");\n  if (!isValidSamlSigningOptions(options)) throw new Error(\"options.privateKey is required\");\n\n  const transforms = options.xmlSignatureTransforms ?? defaultTransforms;\n  const sig = new xmlCrypto.SignedXml();\n  if (options.signatureAlgorithm != null) {\n    sig.signatureAlgorithm = algorithms.getSigningAlgorithm(options.signatureAlgorithm);\n  }\n  sig.addReference(xpath, transforms, algorithms.getDigestAlgorithm(options.digestAlgorithm));\n  sig.signingKey = options.privateKey;\n  sig.computeSignature(xml, {\n    location,\n  });\n\n  return sig.getSignedXml();\n};\n\nexport const parseDomFromString = (xml: string): Promise<Document> => {\n  return new Promise(function (resolve, reject) {\n    function errHandler(msg: string) {\n      return reject(new Error(msg));\n    }\n\n    const dom = new xmldom.DOMParser({\n      /**\n       * locator is always need for error position info\n       */\n      locator: {},\n      /**\n       * you can override the errorHandler for xml parser\n       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n       */\n      errorHandler: {\n        error: errHandler,\n        fatalError: errHandler,\n      },\n    }).parseFromString(xml, \"text/xml\");\n\n    if (!Object.prototype.hasOwnProperty.call(dom, \"documentElement\")) {\n      return reject(new Error(\"Not a valid XML document\"));\n    }\n\n    return resolve(dom);\n  });\n};\n\nexport const parseXml2JsFromString = async (xml: string | Buffer): Promise<XmlJsObject> => {\n  const parserConfig = {\n    explicitRoot: true,\n    explicitCharkey: true,\n    tagNameProcessors: [xml2js.processors.stripPrefix],\n  };\n  const parser = new xml2js.Parser(parserConfig);\n  return parser.parseStringPromise(xml);\n};\n\nexport const buildXml2JsObject = (rootName: string, xml: XmlJsObject): string => {\n  const builderOpts = {\n    rootName,\n    headless: true,\n  };\n  return new xml2js.Builder(builderOpts).buildObject(xml);\n};\n\nexport const buildXmlBuilderObject = (xml: XMLOutput, pretty: boolean): string => {\n  const options = pretty ? { pretty: true, indent: \"  \", newline: \"\\n\" } : {};\n  return xmlbuilder.create(xml).end(options);\n};\n\nexport const promiseWithNameId = async (nameid: Node): Promise<NameID> => {\n  const format = xpath.selectAttributes(nameid, \"@Format\");\n  return {\n    value: nameid.textContent,\n    format: format && format[0] && format[0].nodeValue,\n  };\n};\n\nexport const getNameIdAsync = async (\n  doc: Node,\n  decryptionPvk: string | Buffer | null\n): Promise<NameID> => {\n  const nameIds = xpath.selectElements(\n    doc,\n    \"/*[local-name()='LogoutRequest']/*[local-name()='NameID']\"\n  );\n  const encryptedIds = xpath.selectElements(\n    doc,\n    \"/*[local-name()='LogoutRequest']/*[local-name()='EncryptedID']\"\n  );\n\n  if (nameIds.length + encryptedIds.length > 1) {\n    throw new Error(\"Invalid LogoutRequest\");\n  }\n  if (nameIds.length === 1) {\n    return promiseWithNameId(nameIds[0]);\n  }\n  if (encryptedIds.length === 1) {\n    assertRequired(\n      decryptionPvk,\n      \"No decryption key found getting name ID for encrypted SAML response\"\n    );\n\n    const encryptedDatas = xpath.selectElements(\n      encryptedIds[0],\n      \"./*[local-name()='EncryptedData']\"\n    );\n\n    if (encryptedDatas.length !== 1) {\n      throw new Error(\"Invalid LogoutRequest\");\n    }\n    const encryptedDataXml = encryptedDatas[0].toString();\n\n    const decryptedXml = await decryptXml(encryptedDataXml, decryptionPvk);\n    const decryptedDoc = await parseDomFromString(decryptedXml);\n    const decryptedIds = xpath.selectElements(decryptedDoc, \"/*[local-name()='NameID']\");\n    if (decryptedIds.length !== 1) {\n      throw new Error(\"Invalid EncryptedAssertion content\");\n    }\n    return await promiseWithNameId(decryptedIds[0]);\n  }\n  throw new Error(\"Missing SAML NameID\");\n};\n"]}